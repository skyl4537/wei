# 常量池、栈、堆的比较

​	JAVA中，有六个不同的地方可以存储数据，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。

## 栈

​	存放基本类型的变量数据和对象的引用。JAVA编译器需知道存储在栈内所有数据的大小和生命周期。当没有引用指向数据时，这个数据就会消失。

## 堆

​	存放所有的JAVA对象，即使用new关键字创建的对象，堆进行存储需要一定的时间。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。

## 静态域

​	存放静态成员（static定义的）

## 常量池

​	存放字符串常量和基本类型常量（public static final）。String s1 = "china";  这种创建的数据，就存储在常量池中，String ss1 = new String("china");存储在堆中，对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。

```java
String s1 = "china";
String s2 = "china";
String s3 = "china";
String ss1 = new String("china");
String ss2 = new String("china");
String ss3 = new String("china");
```

![](assets/static-1554954309569.png)

```java
@Test
public void testStringEqu(){
    
    String s = new String("1")+new String("1");
    
    String s1 = "1"+"1";
    String s2 = "11";
    System.out.println(s==s1); //false
    System.out.println(s1==s2); //true
}
```

+运算如果全部是常量那么会在常量池中寻找或者创建

只要含有一个变量或者对象（new String（））最终会在堆中创建一个对象

编译过程为s创建一个对象 new StringBuilder().append("1").append("1").toString();

# HashMap

HashMap 是一个散列表，存储的内容是键值对(key-value)映射。

HashMap中的映射是无序的。

**线程不安全**。可以调用

```java
java.util.Collections#synchronizedMap(Map<K,V> m)
 public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
        return new SynchronizedMap<>(m);
    }
```

将非线程安全改为线程安全的

key、value都可以为null。

**通过“拉链法”解决哈希冲突的**。

## 继承-实现关系

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable
```

![](assets/HashMapExtent.jpg)

## 构造函数

```java
// 默认构造函数。
HashMap()
    //使用默认的初始容量
   static final int DEFAULT_INITIAL_CAPACITY = 16;
   // 默认加载因子
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 指定“容量大小”的构造函数
HashMap(int capacity)
    // 默认加载因子
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 指定“容量大小”和“加载因子”的构造函数
HashMap(int capacity, float loadFactor)
// 包含“子Map”的构造函数
HashMap(Map<? extends K, ? extends V> map)
```

## 重要的成员变量

table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。 
size是HashMap的大小，它是HashMap保存的键值对的数量。 
threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
loadFactor就是加载因子。 
modCount修改次数,对HashMap 内容的修改将增加这个值，是用来实现fail-fast机制的。在迭代过程中，判断 modCount 跟迭代时生成的 expectedModCount的值是否相等，不相等则表示已有其他线程修改了该Map，就会抛出ConcurrentModificationException异常，modCount 声明为 volatile，保证线程之间修改的可见性.

```java
void                 clear() //通过将所有的元素设为null来实现
Object               clone()
//首先通过getEntry(key)获取key对应的Entry，getEntry(key)判断key的hashcode在table中是否存在，如果存在则判断存在table中的key与当前key是否相等
boolean              containsKey(Object key)
boolean              containsValue(Object value)
Set<Entry<K, V>>     entrySet()
V                    get(Object key)
boolean              isEmpty()
Set<K>               keySet()
V                    put(K key, V value)
void                 putAll(Map<? extends K, ? extends V> map)
V                    remove(Object key)
int                  size()
Collection<V>        values()
```

## 造成哈希冲突原因

```java
  
static int indexFor(int h, int length) {
     return h & (length-1);
}

public V put(K key, V value) {
        // 若“key为null”，则将该键值对添加到table[0]中。
        if (key == null)
            return putForNullKey(value);
        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
        int hash = hash(key.hashCode());
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }


    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。
    void addEntry(int hash, K key, V value, int bucketIndex) {
        // 保存“bucketIndex”位置的值到“e”中
        Entry<K,V> e = table[bucketIndex];
        // 设置“bucketIndex”位置的元素为“新Entry”，
        // 设置“e”为“新Entry的下一个节点”
        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小
        if (size++ >= threshold)
            resize(2 * table.length);
    }

```



在hashmap中添加数据时，即put(K key,V value)，HashMap根据key值的hashcode来决定将Entry实例存放在table中的哪个位置【 int i = indexFor(hash, table.length);】，当key的hashcode相同时，，则会出现hash冲突。

使用单链表解决hash冲突的问题，当hashcode存在时，将当前bucketIndex的值存放在新创建的Entry的链表上，然后将新创建的Entry放在 table[bucketIndex] 中。

![](assets/hashconflict.jpg)

JDK 1.8后修改

1.table类型改为Node<K,V>[] table

2.table初始化由原来的在HashMap构造方法中创建修改为在put<Key,Value>时判断table为空和table.length=0再进行初始化

3.Entry单链表会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。1.8引入了红黑树，当链表长度>8时链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。

# Hashtable

​	Hashtable 是一个**散列表**，它存储的内容是**键值对(key-value)映射**。Hashtable 的函数都是**同步的**，它是线程安全的。它的key、value都不可以为null。Hashtable中的映射是无序的。通过**拉链法**解决哈希冲突的。

## 继承-实现关系

```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {}
```

## 构造函数

```java
// 默认构造函数。
public Hashtable() 
	int initialCapacity = 16;
	float loadFactor = 0.75f;
	
// 指定“容量大小”的构造函数
public Hashtable(int initialCapacity) 
	float loadFactor = 0.75f;

// 指定“容量大小”和“加载因子”的构造函数
public Hashtable(int initialCapacity, float loadFactor) 

// 包含“子Map”的构造函数
public Hashtable(Map<? extends K, ? extends V> t)
    int initialCapacity = Math.max(2*t.size(), 11);
	float loadFactor = 0.75f;
```

## 重要的成员变量

**table** 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。

**count**是Hashtable的大小，它是Hashtable保存的键值对的数量。 

**threshold**是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值="容量*加载因子"。

**loadFactor**就是加载因子。 

**modCount**修改次数,对HashMap 内容的修改将增加这个值，是用来实现fail-fast机制的。在迭代过程中，判断 modCount 跟迭代时生成的 expectedModCount的值是否相等，不相等则表示已有其他线程修改了该Map，就会抛出ConcurrentModificationException异常，modCount 声明为 volatile，保证线程之间修改的可见性.

## API

```java
synchronized void                clear()
synchronized Object              clone()
             boolean             contains(Object value)
synchronized boolean             containsKey(Object key)
synchronized boolean             containsValue(Object value)
synchronized Enumeration<V>      elements()
synchronized Set<Entry<K, V>>    entrySet()
synchronized boolean             equals(Object object)
synchronized V                   get(Object key)
synchronized int                 hashCode()
synchronized boolean             isEmpty()
synchronized Set<K>              keySet()
synchronized Enumeration<K>      keys()
synchronized V                   put(K key, V value)
synchronized void                putAll(Map<? extends K, ? extends V> map)
synchronized V                   remove(Object key)
synchronized int                 size()
synchronized String              toString()
synchronized Collection<V>       values()
```

## 造成哈希冲突原因

与HashMap 相同

# ConcurrentHashMap

<http://www.jasongj.com/java/concurrenthashmap/>

> 线程安全，实现方式 CAS+同步锁，数组+链表+红黑树

ConcurrentHashMap不允许key value 为null

java 7 中concurrentHashMap是基于数组和链表的实现方式，最外层为Segment的数组，每个Segment包含一个与HashMap数据结构差不多的链表数组。

![](assets/concurrenthashmap_java7.png)

## 寻址方式

先取该Key的哈希值。并将哈希值的高N位对Segment个数取模从而得到该Key应该属于哪个Segment，而每个segment管理一个类似与HashMap的集合，ConcurentHashMap可以说是多个HashMap的集合，

## 分段锁

segment继承ReentrantLock，可以进行锁的操作，在ConcurrentHashMap进行数据写操作时，对key所在的segment进行锁，但其他segment可以并发进行修改。java7中ConcurrentHashMap就是继续分段锁来控制线程安全的；java8中摒弃了分段锁的思想，而是直接使用一个大的数组，在进行写操作时，查找到key所在的数组位置后，使用synchronized关键字锁住链表头，然后进行操作

# CAS 原理

原子操作指的是不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束。

原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。

CAS（Compare And Set），其作用是对某一个变量进行原子化的更新操作

该算法的思想是：

```shell
CAS(v, e , u)
    - v : 表示要更新的变量
    - e : 表示变量的预期值
    - u : 表示变量的新值

当且仅当 v 的实际值等于 e 值时， 才会将 v 的值设为 u 
如果 v 值和 e 值不同，则说明已经有其他线程做了更新，那么当前线程什么都不做，即更新失败。
CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。
当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。
失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。
```

注:CAS其底层是通过CPU的1条指令来完成3个步骤，因此其本身是一个原子性操作，不存在其执行某一个步骤的时候而被中断的可能。

# http安全性幂等行

## 安全性

​	**一次请求或多次请求对数据资源不造成影响，即为安全**

​	例如：GET  GET请求获取数据资源，只是查看而不对数据进行操作即为安全。 DELETE  DELETE请求删除数据资源，对数据资源造成了影响，即为不安全，同理POST PUT等 。

## 幂等性

​	一次请求或多次相同请求所达到的目的(对数据造成的影响)一致.

| 请求方式 | 请求地址 | 描述                                                         | 幂等   |
| :------- | :------- | :----------------------------------------------------------- | :----- |
| GET      | /emp     | 多次获取相同数据，不会对数据造成影响                         | 幂等   |
| PUT      | /emp/5   | 对要修改的数据进行修改，一次多次执行修改对数据的影响相同，目的是将该条数据修改为请求数据 | 幂等   |
| DELETE   | /emp/5   | 对要删除的数据进行删除，一次多次执行删除对数据的影响相同，目的是将该条数据删除 | 幂等   |
| POST     | /emp     | 插入数据，一次执行及插入一条数据，多次执行则插入多条，对数据造成的影响不同 | 不幂等 |

# ThreadPoolExecutor

## 类构造器

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
		.....
		public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
				BlockingQueue<Runnable> workQueue);
	 
		public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
				BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
	 
		public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
				BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
	 
		public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
			BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
		...
	}
```

## 构造器参数说明

**corePoolSize**：核心线程数，默认情况下,在创建了线程池后，线程池中的线程数为0,task1来请求,会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；

**maximumPoolSize**：线程池最大线程数，在线程池中最多能创建多少个线程

**keepAliveTime**：线程存活时间，表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用。但是如果调用allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；

**workQueue**：阻塞队列，用来存储等待执行的任务。一般使用LinkedBlockingQueue和SynchronousQueue。

**threadFactory**：线程工厂，主要用来创建线程

**handler**：表示拒绝处理任务时的策略，有以下四种取值：

​	ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。(常用) 

​	ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。

​	ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

​	ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 

## 继承关系	

```java
ThreadPoolExecutor extends AbstractExecutorService 、AbstractExecutorService implements ExecutorService、 ExecutorService extends Executor
	public interface Executor {
		void execute(Runnable command);
	}
```

**execute()方法**：在ThreadPoolExecutor进行了具体的实现，通过这个方法可以向线程池提交一个任务，交由线程池去执行。

**submit()方法**：在AbstractExecutorService进行具体的实现，这个方法也是用来向线程池提交任务的，实际上是调用的execute()方法，它利用了Future来获取任务执行结果。

## 线程池状态

| 状态       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| RUNNING    | 创建线程池初始状态                                           |
| SHUTDOWN   | 调用了shutdown()方法，此时线程池不能够接受新的任务，它会等待所有任务执行完毕 |
| STOP       | 调用了shutdownNow()方法，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务； |
| TERMINATED | 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态 |

## 重要成员变量

```java
private final BlockingQueue<Runnable> workQueue;              //任务缓存队列，用来存放等待执行的任务
	private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁
	private final HashSet<Worker> workers = new HashSet<Worker>();  //用来存放工作集
	 
	private volatile long  keepAliveTime;    //线程存活时间   
	private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
	private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
	private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数
	 
	private volatile int   poolSize;       //线程池中当前的线程数
	 
	private volatile RejectedExecutionHandler handler; //任务拒绝策略
	 
	private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程
	 
	private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数
	 
	private long completedTaskCount;   //用来记录已经执行完毕的任务个数
```

## 任务缓存队列及排队策略

​	workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：

​	1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；

​	2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；

​	3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。

## ThreadPoolExecutor运行原理

corePoolSize   maximumPoolSize   task(任务总数)  poolSize(当前线程总数)

poolSize < corePoolSize 时， 当任务处理慢时，则创建新的线程处理新的task

poolSize == corePoolSize 时，将(task-corePoolSize)的任务放入workQueue中，等待处理

task > corePoolSize+workQueue 时,当新任务加入workQueue失败时(任务缓存队列已满),则将线程数增大至 maximumPoolSize来处理添加缓存失败的任务

task > maximumPoolSize+workQueue 根据拒绝策略执行  

# 常用的四种线程池

常用的四种线程池

## newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
   }
```

## newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

## newScheduledThreadPool

```java
 public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }

```

## newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```



# TCP和UDP

## TCP

​	Transmission Control Protocol，传输控制协议，是面向连接的协议。TCP连接时，三次握手，断开时，四次挥手。三次握手（类似打电话），A：喂 （此时A不能确定B是否能接通），B：喂（此时B听到了A的谈话，但不能确定自己说的A是否能正常接收到），A：“B，你好”（此时A收到了B的回复，给B回复能正常接听），谈话开始.

![](assets/TCP3wo.jpg)

四次挥手

![](assets/TCP4hui.jpg)

四次挥手时，主动断开方与被动断开方状态

![](assets/tcpFINStatus.png)

此时客户端为主动断开方，服务端为被动断开方,在tcp进行四次挥手时主动断开方与被动端开方状态转移图

## UDP

​	UDP（User Data Protocol），用户数据报协议，UDP是一个非连接的协议，不需要维护连接状态。UDP尽最大努力交付，不保证可靠交付。UDP是面向报文的。ping命令的原理就是向对方主机发送UDP数据包。

## TCP和UDP区别

|            | TCP          | UDP        |
| ---------- | ------------ | ---------- |
| 是否连接   | 面向连接     | 面向非连接 |
| 传输可靠性 | 可靠         | 不可靠     |
| 应用场合   | 传输大量数据 | 少量数据   |
| 速度       | 慢           | 快         |

## Socket连接

socket是一个五元组，包括[源IP:源端口,TCP,目的IP:目的端口]这个五元组，即标识了一条可用的连接。

## TIME_WAIT作用

防止前一个连接上延迟的数据包或者丢失重传的数据包，被后面复用的连接错误的接收

# SimpleDateFormat

参考网址：https://www.cnblogs.com/java1024/p/8594784.html

## 集成关系

```java
public class SimpleDateFormat extends DateFormat {...}
```

## 造成线程不安全的原因

DateFormat类中有成员变量

```java
protected Calendar calendar;
```

在SimpleDateFormat进行format()时，使用同一个calendar变量进行时间设置，在多线程访问的情况下，则有问题。

源码：

```java
 private StringBuffer format(Date date, StringBuffer toAppendTo,
                                FieldDelegate delegate) {
        // Convert input date to time field list
        calendar.setTime(date);//此处会造成多线程访问线程不安全问题
        boolean useDateFormatSymbols = useDateFormatSymbols();

        for (int i = 0; i < compiledPattern.length; ) {
            int tag = compiledPattern[i] >>> 8;
            int count = compiledPattern[i++] & 0xff;
            if (count == 255) {
                count = compiledPattern[i++] << 16;
                count |= compiledPattern[i++];
            }

            switch (tag) {
            case TAG_QUOTE_ASCII_CHAR:
                toAppendTo.append((char)count);
                break;

            case TAG_QUOTE_CHARS:
                toAppendTo.append(compiledPattern, i, count);
                i += count;
                break;

            default:
                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);
                break;
            }
        }
        return toAppendTo;
    }
```

## 解决方案

借用**ThreadLocal**类

代码实现：

```java
public class ConcurrentDateUtil {	
	private static ThreadLocal<DateFormat> threadLocal = new ThreadLocal<DateFormat>() {
			@Override
			protected DateFormat initialValue() {
				return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			}
		};

		public static Date parse(String dateStr) throws ParseException {
			return threadLocal.get().parse(dateStr);
		}

		public static String format(Date date) {
			return threadLocal.get().format(date);
		}
}
```
# ThreadLocal

## 与Thread关系

Thread中定义了ThreadLocal.ThreadLocalMap 类型的私有变量

```java
public class Thread implements Runnable {
    //Thread中定义了ThreadLocal.ThreadLocalMap 类型的变量
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ...
}
```

## ThreadLocalMap

ThreadLocalMap是ThreadLocal内部类

```java
public class ThreadLocal<T> {
	static class ThreadLocalMap {....}    
}
```

## ThreadLocal方法

### initialValue

```java
 protected T initialValue() {
        return null;
    }
```

### get

调用ThreadLocal中的get()方法，获取本线程的ThreadLocalMap threadLocals变量，如果threadLocals为空，空则调用setInitialValue()方法。如果threadLocals不为空，则获取threadLocals中以当前ThreadLocal对象为key的单链表Entry实例e，e不为空则返回e.value，e为空则调用setInitialValue()方法

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

### getMap(Thread t)

返回当前线程的ThreadLocalMap threadLocals变量

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

### setInitialValue

在调用ThreadLocal中的get()方法是ThreadLocalMap map为空或map中get(key)为空则调用setInitialValue()方法

现获取初始化方法initialValue() v1中的值，若map不为空则将v1 set进map中，若map为空，则创建map并将v1 set 进map中

```java
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

### createMap

```java
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

# tomcat

## Tomcat顶层架构

tomcat顶层结构图

![](assets/tomcatkuang.jpg)

从上图可以看出一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接，多个 Connector 和一个 Container 就形成了一个 Service

Connector用于接受请求并将请求封装成Request和Response来具体处理；

Container用于封装和管理Servlet，以及具体处理request请求；

## Connector的结构

Connector结构图

![](assets/Connector.jpg)

​	Connector
​		-ProtocolHandler
​			-Endpoint
​				-Acceptor(用于监听请求)
​				-AsyncTimeout(用于检查异步Request的超时)
​				-Handler(Handler用于处理接收到的Socket，在内部调用Processor进行处理)
​			-Processor
​			-Adapter

​	ProtocolHandler处理请求，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。

​	Endpoint用来处理底层Socket的网络连接,用来实现TCP/IP协议的。

​	Processor用于将Endpoint接收到的Socket封装成Request,用来实现HTTP协议的。

​	Adapter用于将Request交给Container进行具体的处理,将请求适配到Servlet容器进行具体的处理。

## Container架构

Container架构图

![](assets/Container.jpg)

Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；

Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；整个webapps就是一个Host站点。

Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；

Wrapper：每一Wrapper封装着一个Servlet；

​	Container处理请求是使用责任链模式(Pipeline-Valve)。责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理者继续处理。

Container责任链调用流程：

​	EngineValve1...->StandardEngineValve->HostValve1...StandardHostValve->ContextValve1...StandardContextValve->WrapperValve1...->StandardWrapperValve

​	当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！

​	当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。

# Object

Java最基础和核心的类，在编译时会自动导入；

## hashCode()

```java
public native int hashCode();
```

hashCode根据一定的规则和对象相关的信息生成的一个散列值；

重写hashCode()方法的基本规则：

​	同一个对象多次调用hashCode()，返回的值应相同；

​	两个对象通过equals()比较相同时，hashCode()返回的值也应相同

## equals(Object obj)

```java
public boolean equals(Object obj) 
```

​	比较两个对象的内存地址是否相等

## toString()

```java
public String toString() {
		return getClass().getName() + "@" + Integer.toHexString(hashCode());
	}
```

## finalize()

```java
protected void finalize() throws Throwable { }
```

垃圾回收器准备释放内存的时候，会先调用finalize()。

(1).对象不一定会被回收。

 (2).垃圾回收不是析构函数。

(3).垃圾回收只与内存有关。

 (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。

## clone()

```java
protected native Object clone() throws CloneNotSupportedException;
```

快速创建一个已有对象的副本

Object.clone()方法返回一个Object对象

clone方法首先会判对象是否实现了Cloneable接口，若无则抛出CloneNotSupportedException

object类默认的拷贝为浅拷贝

### 浅拷贝

最终指向了源对象属性的地址

```java
				static class Body implements Cloneable{
					public Head head;
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				}
				static class Head /*implements Cloneable*/{
					public  Face face;
					public Head() {}
					public Head(Face face){this.face = face;}
				} 
```

Body重写clone()，Head不重写clone()

![](assets/qianClone.png)

### 不彻底的深拷贝

```java
static class Body implements Cloneable{
					public Head head;
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				}
				static class Head /*implements Cloneable*/{
					public  Face face;
					public Head() {}
					public Head(Face face){this.face = face;}
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				} 
				static class Face{}
```

Body重写clone()，Head重写clone() Face不重写clone()

![](assets/NoDeepClone.png)

### 深拷贝

```java

				static class Body implements Cloneable{
					public Head head;
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				}
				static class Head /*implements Cloneable*/{
					public  Face face;
					public Head() {}
					public Head(Face face){this.face = face;}
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				} 
				static class Face{
					@Override
					protected Object clone() throws CloneNotSupportedException {
						return super.clone();
					}
				}
```

Body重写clone()，Head重写clone() Face重写clone()

![](assets/deepClone.png)

# try-catch-finally

```java
private int doTry() {
    int x = 1;
    try {
        return ++x;
    } catch (Exception e) {
    } finally {
        ++x;
        System.out.println("finally - " + x);
    }
    return x;
}

@Test
public void doTryTest(){
    int i = doTry();
    System.out.println(i);
}
打印结果:
finally - 3
2
```

在try-catch-finally代码块中不管try中是否有break,return 等都会执行finally模块。也就是说，return前会执行finally语句。执行完finally语句才执行 return。

如果try语句里有return，那么代码的行为如下：
1.如果有返回值，就把返回值保存到局部变量中
2.执行到finally语句里执行
3.执行完finally语句后，返回之前保存在局部变量表里的值

# String Replace

## replace-char

替换单个字符

```java
public String replace(char oldChar, char newChar) {...}
```

## replace-CharSequence

替换字符串

```java
 public String replace(CharSequence target, CharSequence replacement) {
        return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(
                this).replaceAll(Matcher.quoteReplacement(replacement.toString()));
    }
```

## replaceAll

可根据正则表达式进行字符串替换

```java
 public String replaceAll(String regex, String replacement) {
        return Pattern.compile(regex).matcher(this).replaceAll(replacement);
    }
```

## replaceFirst

可根据正则表达式进行字符串替换第一次出现的字符

```java
 public String replaceFirst(String regex, String replacement) {
        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);
    }
```

# JVM

JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)

## 堆区

1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)

2.jvm只有一个堆区(heap)被所有线程共享，只存放对象本身

3.堆是一个不连续的内存空间，分配灵活，速度慢!

## 栈区

- 方法执行的内存模型。`每个方法被调用都会创建一个栈帧`（存储局部变量、操作数、方法出口等）。
- `JVM为每个线程创建一个栈`，用于存放该线程执行方法的信息（实际参数、局部变量等）。
- 栈属于线程私有，不能实现线程间的共享！
- 栈的存储特性是“先进后出，后进先出”。
- 栈是由系统自动分配，速度快！栈是一个连续的内存空间（相比于堆）。

## 方法区（特殊的堆）

JVM只有一个方法区，被所有线程共享！

方法区实际也是堆，只是用于存储类、常量相关的信息！

用来存放程序中永远不变或唯一的内容（类信息{Class对象}、静态变量、字符串常量等）。

```java
public class Dog{
    private String name;
    public Dog(String name){
        this.name = name;
    }
}

public String Person{
    private String name;
    private int age;
    private Dog dog;
    public Person(int age,String name){
        this.age = age;
        this.name = name;
    }
    
    public void play(){
        System.out.println("play with" + this.dog.name);
    }
}

public class Test(){
    public static void main(String[] args){
        Person p = new Person(18,"惊欢");
        p.dog = new Dog("董岩");
        p.play();
    }
}
```

jvm加载对象流程图

![](assets/jvmload-1555896467293.png)



# switch表达式支持的类型

JDK1.6（及之前版本）支持byte,char,short,int

JDK1.7新特性支持了String类型

# 静态代码块-代码块-构造方法

```java
 class F {
    static {
        System.out.print("F-S{} ");
    }

    {
        System.out.print("F{} ");
    }

    F() {
        System.out.print("F() ");
    }
}

 class S extends F {
    static {
        System.out.print("S-S{} ");
    }

    {
        System.out.print("S{} ");
    }

    S() {
        System.out.print("S() ");
    }

    public static void main(String[] args) {
        System.out.print("S-M() ");
        new S(); //F-S{} S-S{} S-M() F{} F() S{} S()
    }
}
```

1.加载子类S的class文件时，先加载父类F的class文件，

2.加载class文件时，先执行F类的static{}静态代码块，且静态代码块只在加载class文件时执行一次，

3.后加载子类S的class文件，加载S静态代码块，

4.为main方法分配栈帧，执行main方法

5.创建S对象先调用父类F的代码块，后调用F的构造方法

6.在调用S的代码块，后调用S的构造方法

7.代码块与构造方法类似，每次new对象时都会执行

# 集合

集合之间的集成与实现关系图

![](assets/collection.jpg)

## collection接口

Collection依赖于Iterator，实现类需要实现iterator()函数

有List和Set两大分支

List有序队列

可根据索引进行检索，实现类有LinkedList，ArrayList，Vector，Stack

Set不允许有重复元素的集合

实现类有HastSet和TreeSet，HashSet通过HashMap实现，TreeSet通过TreeMap实现

## Map

映射接口，key-value键值对

AbstractMap是个抽象类，实现了Map接口中的大部分接口，HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable继承于Dictionary，并实现了Map接口。

## 工具类

Arrays，Collections，可进行操作数组、集合

# ArrayList

ArrayList是一个动态数组

ArrayList实现了RandmoAccess接口，RandmoAccess接口为标记接口，实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。

**线程不安全**。可以调用

```java
java.util.Collections#synchronizedList(java.util.List<T>)
    public static <T> List<T> synchronizedList(List<T> list) {
        return (list instanceof RandomAccess ?
                new SynchronizedRandomAccessList<>(list) :
                new SynchronizedList<>(list));
    }
```

将非线程安全改为线程安全的

## 继承与实现

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

## 构造函数

```java
public ArrayList() {
    //初始化 DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
	this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
//默认数组初始化容量=10
public ArrayList(int initialCapacity){...}
public ArrayList(@NotNull Collection<? extends E> c) {...}
```

## 重要的成员变量

elementData：Object[]类型的动态数组，elementData数组的大小会根据ArrayList容量的增长而动态的增长。

size：动态数组的实际大小

## 重要方法

add(E e)

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

Arrays中数组copy的方法
 public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
        @SuppressWarnings("unchecked")
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
}
```

在向数组中添加数据时，先查看数组的(size+1)-length>0是否大于0，如果值大于0，表示当前数组已填满，数组长度需要扩充。将数组的大小调整为 int newCapacity = oldCapacity + (oldCapacity >> 1);创建一个新的数组，将原数组的数据copy到新的数组，将新的数组返回，然后将新的数组添加到数组当前size++的位置。

remove(int index)

```java
public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
```

remove指定index的数据时，先获取当前数据之后的数据长度，将index+1之后的数据覆盖index之后的数据，即index+1之后的数据都向前移动一格，然后将索引为[--size]的值置为null。

clear()

```java
 public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }
```

使用for循环遍历数组，并将数组中的值都置为null

# CopyOnWriteArrayList

线程安全与ArrayList类似，CopyOnWriteArrayList在进行数据添加时，先将对象锁住，不允许其他线程调用add方法，将原数组copy到新的数组进行添加，然后将数组对象的引用指向新的数组，读取数据时不进行加锁

## 继承与实现

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

## 构造函数

```java
public CopyOnWriteArrayList() {
        setArray(new Object[0]);
    }
public CopyOnWriteArrayList(Collection<? extends E> c) {...}
public CopyOnWriteArrayList(E[] toCopyIn) {
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
    }

```

CopyOnWriteArrayList默认数组大小为0

## 重要的成员变量

```java
final transient ReentrantLock lock = new ReentrantLock(); 
private transient volatile Object[] array;
```

## 重要的方法

add

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

remove(int index)

```java
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

get(int index)

```java
public E get(int index) {
    return get(getArray(), index);
}
```

# LinkedList

LinkedList继承AbstractSequentialList是双向链表，LinkedList 是非同步的，即线程不安全

## 继承与实现

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```

![](assets/LinkedList.jpg)

AbstractSequentialList 类实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数，这些接口可随机访问list

## 构造函数

```java
public LinkedList() {}
public LinkedList(Collection<? extends E> c) {
   this();
   addAll(c);
}
```

## 重要的成员变量

```java
//当前链表的第一个值
transient Node<E> first
//当前链表的最后一个值
transient Node<E> last;
//当前链表的长度
transient int size = 0;
transient关键字表示多线程可见

//内部类
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
   }
```

## 重要方法

### add()、offer(E e)、push(E e)

```java
public boolean add(E e) {
        linkLast(e);
        return true;
    }
public boolean offer(E e) {
        return add(e);
    }
void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
public void push(E e) {
        addFirst(e);
    }
```

将新数据添加到链表最末端

### remove()、removeFirst()、poll()、pollFirst()、pop()

```java
 public E remove() {
     return removeFirst();
 }
public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }
public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
public E pollFirst() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }
public E pop() {
        return removeFirst();
    }
private E unlinkFirst(Node<E> f) {
        // assert f == first && f != null;
        final E element = f.item;
        final Node<E> next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }

```

删除第一个元素并返回

### peek()、peekFirst()、getFirst()

```java
 public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
    }
public E peekFirst() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
     }
public E getFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }
```

获取当前链表的第一个元素，当链表为null时，getFirst抛异常而其他两个返回null

### get(int index)

```java
public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }
Node<E> node(int index) {
        // assert isElementIndex(index);

        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```

获取指定索引的值，先判断index是否小于size/2,若小于则从前往后查，若大于则从后往前查，查找成功后返回

# Vector

与ArrayList实现方式类似，是线程安全的

## 继承与实现

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

## 重要的成员变量

```java
//存放数据的动态数组
protected Object[] elementData;
//动态数组的实际大小
protected int elementCount;
//动态数组的增长系数
protected int capacityIncrement;
```

capacityIncrement主要作用是当数组容量不足时，根据其大小进行数组的扩充，如果该值=0,则按照原来数组的大小*2进行扩充

## 重要方法

add()

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

其他方法的实现与ArrayList类似，只是方法添加了synchronized关键字，添加了同步机制，不可以进行多线程同时访问。

# 重载与重写

| 区别点   | 重载方法 | 重写方法                                       |
| -------- | -------- | ---------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改                                   |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

# LocalTime

> 时间类

```java
LocalTime now = LocalTime.now();//打印结果：19:57:08.025
LocalDate now2 = LocalDate.now();// 2019-06-25
LocalDateTime now1 = LocalDateTime.now(); //打印结果 2019-06-25T20:02:22.408
```

# DateTimeFormatter

> 时间格式化，线程安全

```java
String format = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd " +
                "HH:mm:ss.SSS"));//2019-06-25 20:17:06.645
```

# StringBuffer

> 线程安全，效率低

```java
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

# TimeUnit

> 时间工具类

```java
//线程休眠指定时间单位
TimeUnit.SECONDS.sleep(2);//线程休眠
```

# IOUtils

> toByteArray

```java
//读取流中的字符串
String line = IOUtils.toString(in, "UTF-8"); 
```

```java
//读取网络图片，并本地保存
String u = "http://192.168.5.25:8080/webpark/img/main.jpg";
URL url = new URL(u);
byte[] data = IOUtils.toByteArray(url);
File f = new File("D:\\var\\lib\\webpark\\image\\20190720\\1231231323\\2.jpg");
FileOutputStream out = new FileOutputStream(f);
out.write(data);
```

> 文件拷贝copy

```java
@Test
public void testCopyFile() {
    File src = new File("D:\\var\\lib\\webpark\\image\\20190720\\1231231323\\newInterface.20190713_17.log.zip");
    File dest = new File("D:\\var\\lib\\webpark\\image\\20190720\\1231231323\\newInterface.20190713_17.log0.zip");
    try (FileInputStream in = new FileInputStream(src);
         FileOutputStream out = new FileOutputStream(dest)) {
        //             FileWriter out = new FileWriter(dest)) { //copy文本中含有中文的文本文件，使用字符流的方式处理，其他建议选用字节流处理
        IOUtils.copy(in, out); //拷贝流，从输入到输出
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

# FileUtils

> copyURLToFile

```java
@Test
public void testUrlSaveFileTwoPattern() throws Exception{
    String u = "http://192.168.5.25:8080/webpark/img/main.jpg";
    //FileUtils.copyURLToFile最终调用IOUtils.copy(in, out);
    FileUtils.copyURLToFile(new URL(u),new File("D:\\var\\lib\\webpark\\image\\20190720\\1231231323\\4.jpg"),5*1000,5*1000);
}
```



# 字节流&字符流

> 字节流

字节流主要是操作byte类型数据，以byte数组为准，主要操作类就是OutputStream、InputStream

处理音频文件、图片、歌曲，就用字节流好点

字节输出流:

```java
public abstract class OutputStream implements Closeable, Flushable {}
```

OutputStream为抽象类，通过实例化其子类，向上转型实例化此类，常见子类FileOutputStream

```java
public abstract class InputStream implements Closeable {}
```

字节输入流：

```java
public abstract class InputStream implements Closeable {}
```

InputStream为抽象类，通过实例化其子类，向上转型实例化此类，常见子类FileInputStream

>字符流

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的

字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串

字符输出流：Writer

```java
public abstract class Writer implements Appendable, Closeable, Flushable {}
```

常见子类FileWriter

字符输入流：Reader

```java
public abstract class Reader implements Readable, Closeable {}
```

常见子类FileReader

>字节流与字符流的区别

1.字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的

2.字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容

# IO和NIO

> 传统单线程IO

```java
public class OioServer {

    @SuppressWarnings("resource")
    public static void main(String[] args) throws Exception {
        //创建socket服务,监听10101端口
        ServerSocket server=new ServerSocket(10101);
        System.out.println("服务器启动！");
        while(true){
            //获取一个套接字（阻塞）
            final Socket socket = server.accept();
            System.out.println("来个一个新客户端！");
            //业务处理
            handler(socket);			
        }
    }

    /**
	 * 读取数据
	 * @param socket
	 * @throws Exception
	 */
    public static void handler(Socket socket){
        try {
            byte[] bytes = new byte[1024];
            InputStream inputStream = socket.getInputStream();

            while(true){
                //读取数据（阻塞）
                int read = inputStream.read(bytes);
                if(read != -1){
                    System.out.println(new String(bytes, 0, read));
                }else{
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            try {
                System.out.println("socket关闭");
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

其中，server.accept();该方法为获取一个socket连接，在未接收到客户端连接的时候它会一直阻塞

inputStream.read(bytes)，当客户端连接成功后，程序阻塞等待读取客户端发送的数据

在单线程的io中一个服务器只能服务一个客户端，并等待该客户端发送数据

> 多线程IO

```java
public class OioServer {

    @SuppressWarnings("resource")
    public static void main(String[] args) throws Exception {

        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
        //创建socket服务,监听9999端口
        ServerSocket server=new ServerSocket(9999);
        System.out.println("服务器启动！");
        while(true){
            //获取一个套接字（阻塞）
            final Socket socket = server.accept();
            System.out.println("来个一个新客户端！");
            newCachedThreadPool.execute(new Runnable() {

                @Override
                public void run() {
                    //业务处理
                    handler(socket);
                }
            });

        }
    }

    /**
	 * 读取数据
	 * @param socket
	 * @throws Exception
	 */
    public static void handler(Socket socket){
        try {
            byte[] bytes = new byte[1024];
            InputStream inputStream = socket.getInputStream();

            while(true){
                //读取数据（阻塞）
                int read = inputStream.read(bytes);
                if(read != -1){
                    System.out.println(new String(bytes, 0, read));
                }else{
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            try {
                System.out.println("socket关闭");
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

每连接一个客户端，服务端必须分配 一个线程为客户端使用，短连接的时候处理完释放线程，但是长连接则会造成服务器崩溃

> nio

nio被称为非阻塞的io。

```java
public class NIOServer {
    // 通道管理器
    private Selector selector;

    /**
	 * 获得一个ServerSocket通道，并对该通道做一些初始化的工作
	 * 
	 * @param port
	 *            绑定的端口号
	 * @throws IOException
	 */
    public void initServer(int port) throws IOException {
        // 获得一个ServerSocket通道
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        // 设置通道为非阻塞
        serverChannel.configureBlocking(false);
        // 将该通道对应的ServerSocket绑定到port端口
        serverChannel.socket().bind(new InetSocketAddress(port));
        // 获得一个通道管理器
        this.selector = Selector.open();
        // 将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，
        // 当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    }

    /**
	 * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理
	 * 
	 * @throws IOException
	 */
    public void listen() throws IOException {
        System.out.println("服务端启动成功！");
        // 轮询访问selector
        while (true) {
            // 当注册的事件到达时，方法返回；否则,该方法会一直阻塞
            selector.select();
            // 获得selector中选中的项的迭代器，选中的项为注册的事件
            Iterator<?> ite = this.selector.selectedKeys().iterator();
            while (ite.hasNext()) {
                SelectionKey key = (SelectionKey) ite.next();
                // 删除已选的key,以防重复处理
                ite.remove();

                handler(key);
            }
        }
    }

    /**
	 * 处理请求
	 * 
	 * @param key
	 * @throws IOException
	 */
    public void handler(SelectionKey key) throws IOException {

        // 客户端请求连接事件
        if (key.isAcceptable()) {
            handlerAccept(key);
            // 获得了可读的事件
        } else if (key.isReadable()) {
            handelerRead(key);
        }
    }

    /**
	 * 处理连接请求
	 * 
	 * @param key
	 * @throws IOException
	 */
    public void handlerAccept(SelectionKey key) throws IOException {
        ServerSocketChannel server = (ServerSocketChannel) key.channel();
        // 获得和客户端连接的通道
        SocketChannel channel = server.accept();
        // 设置成非阻塞
        channel.configureBlocking(false);

        // 在这里可以给客户端发送信息哦
        System.out.println("新的客户端连接");
        // 在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。
        channel.register(this.selector, SelectionKey.OP_READ);
    }

    /**
	 * 处理读的事件
	 * 
	 * @param key
	 * @throws IOException
	 */
    public void handelerRead(SelectionKey key) throws IOException {
        // 服务器可读取消息:得到事件发生的Socket通道
        SocketChannel channel = (SocketChannel) key.channel();
        // 创建读取的缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        int read = channel.read(buffer);
        if(read > 0){
            byte[] data = buffer.array();
            String msg = new String(data).trim();
            try {
                System.out.println("开始接收数据……");
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            System.out.println("服务端收到信息：" + msg);

            //回写数据
            ByteBuffer outBuffer = ByteBuffer.wrap("好的".getBytes());
            channel.write(outBuffer);// 将消息回送给客户端
        }else{
            System.out.println("客户端关闭");
            key.cancel();
        }
    }

    /**
	 * 启动服务端测试
	 * 
	 * @throws IOException
	 */
    public static void main(String[] args) throws IOException {
        NIOServer server = new NIOServer();
        server.initServer(8000);
        server.listen();
    }

}
```

nio最重要的就是selector.select(); 该方法看似和单线程的server.accept();方法类似, 都是单线程while循环去获取；单线程的io对应的一个client的对象，而nio的线程是被selector独占的，selector对应的是一组对象池，通过selector.select()的方法来获取对象列表进行一一处理。

selector.select()，该方法是一个阻塞的方法。它会检测事件和类型，它会将对应事件类型的就绪的channel随着selectedKey返回。比如说客户端要进行read操作，select（）方法检测到该事件，它就会将selector中注册的并且read就绪的channel返回。而如果是一个刚连接的client，select（）方法会返回ACCEPT状态的serverChannel进行新channel的注册。所以说在selector中的channel是在不断增长的。

> 传统IO示例图

![](assets/io.png)

传统IO就像一个餐厅，进来一个客人分配一个服务员，资源消耗大

> nio实例图

![](assets/nio.png)

nio的方式则是进入的客人，先到服务员那里去登记，然后由一个服务员根据你登记的需要服务的事项（在nio中成为状态）为所有客人服务，大大节约了资源

> IO和nio优缺点

传统IO每连接一个客户端分配一个线程，这种方式具有很高的响应速度，在连接数较少的情况下非常有效，但是长连接过多时会出现资源不足的情况

NIO是面向缓冲区的操作，所以在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕。

# 泛型

```http
https://segmentfault.com/a/1190000014120746
```

# 等差等比定时任务

```java
class Query implements Runnable {
    private int index = 0;
    private int count = 0;
    int delay = 3;
    long initDelay = 5;

    @Override
    public void run() {
        if (count == index) {
            System.out.println(LocalTime.now());
            count = 1;
            index++;  //等差
            //index = 0 == index ? 1 : index * 2; //等比
        } else {
            count++;
        }
    }
}

public static void main(String[] args) {
    System.out.println(LocalTime.now());
    ScheduledExecutorService schedule = Executors.newScheduledThreadPool(1);
    Query b = new StringTest().new Query();
    schedule.scheduleWithFixedDelay(b, b.initDelay, b.delay, TimeUnit.SECONDS);

}
```

