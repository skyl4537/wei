# 常量池、栈、堆的比较

​	JAVA中，有六个不同的地方可以存储数据，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。

	## 栈   

​	存放基本类型的变量数据和对象的引用。JAVA编译器需知道存储在栈内所有数据的大小和生命周期。当没有引用指向数据时，这个数据就会消失。

	## 堆

​	存放所有的JAVA对象，即使用new关键字创建的对象，堆进行存储需要一定的时间。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。

## 静态域

​	存放静态成员（static定义的）

	## 常量池

​	存放字符串常量和基本类型常量（public static final）。String s1 = "china";  这种创建的数据，就存储在常量池中，String ss1 = new String("china");存储在堆中，对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。

```java
String s1 = "china";
String s2 = "china";
String s3 = "china";
String ss1 = new String("china");
String ss2 = new String("china");
String ss3 = new String("china");
```

![](C:\Users\zz\Desktop\わたし\spring\tu\栈-堆-常量池.png)



# HashMap

​	HashMap 是一个散列表，存储的内容是键值对(key-value)映射。HashMap中的映射是无序的。线程不安全。key、value都可以为null。**通过“拉链法”解决哈希冲突的**。

## 集成-实现关系

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable
```

![](C:\Users\zz\Desktop\わたし\spring\tu\HashMap集成关系图.jpg)

## 构造函数

```java
// 默认构造函数。
HashMap()
    //使用默认的初始容量
   static final int DEFAULT_INITIAL_CAPACITY = 16;
   // 默认加载因子
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 指定“容量大小”的构造函数
HashMap(int capacity)
    // 默认加载因子
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 指定“容量大小”和“加载因子”的构造函数
HashMap(int capacity, float loadFactor)
// 包含“子Map”的构造函数
HashMap(Map<? extends K, ? extends V> map)
```

## 重要的成员变量

​	**table** 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。 
　　**size**是HashMap的大小，它是HashMap保存的键值对的数量。 
　　**threshold**是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
　　**loadFactor**就是加载因子。 
　　**modCount**是用来实现fail-fast机制的。

## API

```java
void                 clear() //通过将所有的元素设为null来实现
Object               clone()
//首先通过getEntry(key)获取key对应的Entry，getEntry(key)判断key的hashcode在table中是否存在，如果存在则判断存在table中的key与当前key是否相等
boolean              containsKey(Object key)
boolean              containsValue(Object value)
Set<Entry<K, V>>     entrySet()
V                    get(Object key)
boolean              isEmpty()
Set<K>               keySet()
V                    put(K key, V value)
void                 putAll(Map<? extends K, ? extends V> map)
V                    remove(Object key)
int                  size()
Collection<V>        values()
```

## 造成哈希冲突原因

```java
  
static int indexFor(int h, int length) {
     return h & (length-1);
}

public V put(K key, V value) {
        // 若“key为null”，则将该键值对添加到table[0]中。
        if (key == null)
            return putForNullKey(value);
        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
        int hash = hash(key.hashCode());
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }


    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。
    void addEntry(int hash, K key, V value, int bucketIndex) {
        // 保存“bucketIndex”位置的值到“e”中
        Entry<K,V> e = table[bucketIndex];
        // 设置“bucketIndex”位置的元素为“新Entry”，
        // 设置“e”为“新Entry的下一个节点”
        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小
        if (size++ >= threshold)
            resize(2 * table.length);
    }

```



在hashmap中添加数据时，即put(K key,V value)，HashMap根据key值的hashcode来决定将Entry实例存放在table中的哪个位置【 int i = indexFor(hash, table.length);】，当key的hashcode相同时，，则会出现hash冲突。

使用单链表解决hash冲突的问题，当hashcode存在时，将当前bucketIndex的值存放在新创建的Entry的链表上，然后将新创建的Entry放在 table[bucketIndex] 中。

![](C:\Users\zz\Desktop\わたし\spring\tu\hash冲突解决.jpg)