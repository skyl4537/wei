运行时数据区域
根据线程是否共享分为
线程共享
	1.方法区
		用于存储已被虚拟机加载的类信息、方法信息、常量、静态变量等
	1.1运行时常量池
		为方法区的一部分
	2.java堆
线程私有
	1.程序计数器
	2.java栈
	3.本地方法栈

强引用 new 处的对象  不标记
软引用 softReference
弱引用 weakReference
虚引用 phantomReference

判断对象是否存活算法
1.引用计数算法
	给对象添加一个引用计数器，有引用则引用计数器值为1，无引用值为0，无法解决对象间的相互引用
2.可发性分析算法
	GCRoots无法到达的对象，则为可回收对象

垃圾收集算法
1.标记-清除算法
	算法分为两个阶段:标记、清除
	1.首先标记出所有要回收的对象
	2.标记完成后统一回收所有被标记的对象
	不足：
	1.效率低
	2.空间问题，标记清除后产生大量的不连续内存碎片，导致程序中如果需要分配大内存对象时，无法找到足够的连续内存

2.复制算法
	将内存分成相等的两块内存A、B，每次只使用一块（A或B其中一块），A用完后，将存活对象复制到B中，将A清理掉，每次都对半块内存进行内存回收
	不足：对象存活率较高时，进行较多的复制操作，效率会变低，老年代一般不能直接选用这种算法
	
	Eden(80%) Survivor(10%) Survivor(10%) 老年代
	将Eden和Survivor中存活的对象复制到另一个Survivor区中，清理掉Eden+Survivor,如果存活对象>10%的内存，需要依赖老年代进行分配担保

3.标记-整理
	1.首先标记出所有要回收的对象
	2.将存活的对象向一端移动，清理掉存活对象边界以外的内存

4.分代收集算法
	新生代选用复制算法
	老年代选用标记-清除或标记整理
	



	

